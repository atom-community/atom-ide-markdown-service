{"version":3,"file":"main.js","sources":["../lib/utils.js","../node_modules/marked/src/defaults.js","../node_modules/marked/src/helpers.js","../node_modules/marked/src/Tokenizer.js","../node_modules/marked/src/rules.js","../node_modules/marked/src/Lexer.js","../node_modules/marked/src/Renderer.js","../node_modules/marked/src/TextRenderer.js","../node_modules/marked/src/Slugger.js","../node_modules/marked/src/Parser.js","../node_modules/marked/src/marked.js","../node_modules/dompurify/dist/purify.es.js","../lib/renderer.js","../lib/main.js"],"sourcesContent":["const scopesByFenceName = {\n  'bash': 'source.shell',\n  'sh': 'source.shell',\n  'powershell': 'source.powershell',\n  'ps1': 'source.powershell',\n  'c': 'source.c',\n  'c++': 'source.cpp',\n  'cpp': 'source.cpp',\n  'coffee': 'source.coffee',\n  'coffee-script': 'source.coffee',\n  'coffeescript': 'source.coffee',\n  'cs': 'source.cs',\n  'csharp': 'source.cs',\n  'css': 'source.css',\n  'sass': 'source.sass',\n  'scss': 'source.css.scss',\n  'erlang': 'source.erl',\n  'go': 'source.go',\n  'html': 'text.html.basic',\n  'java': 'source.java',\n  'javascript': 'source.js',\n  'js': 'source.js',\n  'json': 'source.json',\n  'less': 'source.less',\n  'mustache': 'text.html.mustache',\n  'objc': 'source.objc',\n  'objective-c': 'source.objc',\n  'php': 'text.html.php',\n  'py': 'source.python',\n  'python': 'source.python',\n  'rb': 'source.ruby',\n  'ruby': 'source.ruby',\n  'rust': 'source.rust',\n  'text': 'text.plain',\n  'toml': 'source.toml',\n  'ts': 'source.ts',\n  'typescript': 'source.ts',\n  'xml': 'text.xml',\n  'yaml': 'source.yaml',\n  'yml': 'source.yaml'\n};\n\n\nexport function scopeForFenceName (fenceName: string): string {\n    fenceName = fenceName.toLowerCase();\n    let result = `source.${fenceName}`;\n    if (scopesByFenceName[fenceName] != null) {\n      result = scopesByFenceName[fenceName]\n    }\n    return result;\n}\n\nexport function fenceNameForScope (scope: string): string {\n    scope = scope.toLowerCase();\n    let result = Object.keys(scopesByFenceName).filter(s => s == scope);\n    let resultOut: string\n    if (result.length) {\n      resultOut = result[0];\n    }\n    else {\n      resultOut = scope.substr(scope.lastIndexOf('.') + 1);\n    }\n    return resultOut;\n}\n","function getDefaults() {\n  return {\n    baseUrl: null,\n    breaks: false,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: null,\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartLists: false,\n    smartypants: false,\n    tokenizer: null,\n    walkTokens: null,\n    xhtml: false\n  };\n}\n\nfunction changeDefaults(newDefaults) {\n  module.exports.defaults = newDefaults;\n}\n\nmodule.exports = {\n  defaults: getDefaults(),\n  getDefaults,\n  changeDefaults\n};\n","/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = /[&<>\"']/g;\nconst escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\nconst escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\nconst escapeReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n  regex = regex.source || regex;\n  opt = opt || '';\n  const obj = {\n    replace: (name, val) => {\n      val = val.source || val;\n      val = val.replace(caret, '$1');\n      regex = regex.replace(name, val);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(regex, opt);\n    }\n  };\n  return obj;\n}\n\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    let prot;\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(nonWordAndColonTest, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (justDomain.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n  const relativeBase = base.indexOf(':') === -1;\n\n  if (href.substring(0, 2) === '//') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(protocol, '$1') + href;\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(domain, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\n\nconst noopTest = { exec: function noopTest() {} };\n\nfunction merge(obj) {\n  let i = 1,\n    target,\n    key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false,\n        curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(/ \\|/);\n  let i = 0;\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n// /c*$/ is vulnerable to REDOS.\n// invert: Remove suffix of non-c chars instead. Default falsey.\nfunction rtrim(str, c, invert) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.substr(0, l - suffLen);\n}\n\nfunction findClosingBracket(str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n  const l = str.length;\n  let level = 0,\n    i = 0;\n  for (; i < l; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction checkSanitizeDeprecation(opt) {\n  if (opt && opt.sanitize && !opt.silent) {\n    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n  }\n}\n\nmodule.exports = {\n  escape,\n  unescape,\n  edit,\n  cleanUrl,\n  resolveUrl,\n  noopTest,\n  merge,\n  splitCells,\n  rtrim,\n  findClosingBracket,\n  checkSanitizeDeprecation\n};\n","const { defaults } = require('./defaults.js');\nconst {\n  rtrim,\n  splitCells,\n  escape,\n  findClosingBracket\n} = require('./helpers.js');\n\nfunction outputLink(cap, link, raw) {\n  const href = link.href;\n  const title = link.title ? escape(link.title) : null;\n  const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n  if (cap[0].charAt(0) !== '!') {\n    return {\n      type: 'link',\n      raw,\n      href,\n      title,\n      text\n    };\n  } else {\n    return {\n      type: 'image',\n      raw,\n      href,\n      title,\n      text: escape(text)\n    };\n  }\n}\n\nfunction indentCodeCompensation(raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nmodule.exports = class Tokenizer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  space(src) {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap) {\n      if (cap[0].length > 1) {\n        return {\n          type: 'space',\n          raw: cap[0]\n        };\n      }\n      return { raw: '\\n' };\n    }\n  }\n\n  code(src, tokens) {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const lastToken = tokens[tokens.length - 1];\n      // An indented code block cannot interrupt a paragraph.\n      if (lastToken && lastToken.type === 'paragraph') {\n        return {\n          raw: cap[0],\n          text: cap[0].trimRight()\n        };\n      }\n\n      const text = cap[0].replace(/^ {4}/gm, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text\n      };\n    }\n  }\n\n  fences(src) {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '');\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim() : cap[2],\n        text\n      };\n    }\n  }\n\n  heading(src) {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text: cap[2]\n      };\n    }\n  }\n\n  nptable(src) {\n    const cap = this.rules.block.nptable.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n        raw: cap[0]\n      };\n\n      if (item.header.length === item.align.length) {\n        let l = item.align.length;\n        let i;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.cells.length;\n        for (i = 0; i < l; i++) {\n          item.cells[i] = splitCells(item.cells[i], item.header.length);\n        }\n\n        return item;\n      }\n    }\n  }\n\n  hr(src) {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: cap[0]\n      };\n    }\n  }\n\n  blockquote(src) {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ *> ?/gm, '');\n\n      return {\n        type: 'blockquote',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  list(src) {\n    const cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let raw = cap[0];\n      const bull = cap[2];\n      const isordered = bull.length > 1;\n      const isparen = bull[bull.length - 1] === ')';\n\n      const list = {\n        type: 'list',\n        raw,\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: []\n      };\n\n      // Get each top-level item.\n      const itemMatch = cap[0].match(this.rules.block.item);\n\n      let next = false,\n        item,\n        space,\n        b,\n        addBack,\n        loose,\n        istask,\n        ischecked;\n\n      const l = itemMatch.length;\n      for (let i = 0; i < l; i++) {\n        item = itemMatch[i];\n        raw = item;\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+[.)]) */, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (i !== l - 1) {\n          b = this.rules.block.bullet.exec(itemMatch[i + 1])[0];\n          if (isordered ? b.length === 1 || (!isparen && b[b.length - 1] === ')')\n            : (b.length > 1 || (this.options.smartLists && b !== bull))) {\n            addBack = itemMatch.slice(i + 1).join('\\n');\n            list.raw = list.raw.substring(0, list.raw.length - addBack.length);\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        if (loose) {\n          list.loose = true;\n        }\n\n        // Check for task list items\n        istask = /^\\[[ xX]\\] /.test(item);\n        ischecked = undefined;\n        if (istask) {\n          ischecked = item[1] !== ' ';\n          item = item.replace(/^\\[[ xX]\\] +/, '');\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: istask,\n          checked: ischecked,\n          loose: loose,\n          text: item\n        });\n      }\n\n      return list;\n    }\n  }\n\n  html(src) {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      return {\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        raw: cap[0],\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]\n      };\n    }\n  }\n\n  def(src) {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n      const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n      return {\n        tag,\n        raw: cap[0],\n        href: cap[2],\n        title: cap[3]\n      };\n    }\n  }\n\n  table(src) {\n    const cap = this.rules.block.table.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        item.raw = cap[0];\n\n        let l = item.align.length;\n        let i;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.cells.length;\n        for (i = 0; i < l; i++) {\n          item.cells[i] = splitCells(\n            item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n            item.header.length);\n        }\n\n        return item;\n      }\n    }\n  }\n\n  lheading(src) {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1]\n      };\n    }\n  }\n\n  paragraph(src) {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      };\n    }\n  }\n\n  text(src, tokens) {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      const lastToken = tokens[tokens.length - 1];\n      if (lastToken && lastToken.type === 'text') {\n        return {\n          raw: cap[0],\n          text: cap[0]\n        };\n      }\n\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0]\n      };\n    }\n  }\n\n  escape(src) {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: escape(cap[1])\n      };\n    }\n  }\n\n  tag(src, inLink, inRawBlock) {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!inLink && /^<a /i.test(cap[0])) {\n        inLink = true;\n      } else if (inLink && /^<\\/a>/i.test(cap[0])) {\n        inLink = false;\n      }\n      if (!inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        inRawBlock = true;\n      } else if (inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        inRawBlock = false;\n      }\n\n      return {\n        type: this.options.sanitize\n          ? 'text'\n          : 'html',\n        raw: cap[0],\n        inLink,\n        inRawBlock,\n        text: this.options.sanitize\n          ? (this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0]))\n          : cap[0]\n      };\n    }\n  }\n\n  link(src) {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const lastParenIndex = findClosingBracket(cap[2], '()');\n      if (lastParenIndex > -1) {\n        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n        const linkLen = start + cap[1].length + lastParenIndex;\n        cap[2] = cap[2].substring(0, lastParenIndex);\n        cap[0] = cap[0].substring(0, linkLen).trim();\n        cap[3] = '';\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        } else {\n          title = '';\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n      href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n      const token = outputLink(cap, {\n        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n        title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n      }, cap[0]);\n      return token;\n    }\n  }\n\n  reflink(src, links) {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n        || (cap = this.rules.inline.nolink.exec(src))) {\n      let link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = links[link.toLowerCase()];\n      if (!link || !link.href) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text\n        };\n      }\n      const token = outputLink(cap, link, cap[0]);\n      return token;\n    }\n  }\n\n  strong(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.strong.start.exec(src);\n\n    if (match && (!match[1] || (match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))))) {\n      maskedSrc = maskedSrc.slice(-1 * src.length);\n      const endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;\n\n      endReg.lastIndex = 0;\n\n      let cap;\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));\n        if (cap) {\n          return {\n            type: 'strong',\n            raw: src.slice(0, cap[0].length),\n            text: src.slice(2, cap[0].length - 2)\n          };\n        }\n      }\n    }\n  }\n\n  em(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.em.start.exec(src);\n\n    if (match && (!match[1] || (match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))))) {\n      maskedSrc = maskedSrc.slice(-1 * src.length);\n      const endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;\n\n      endReg.lastIndex = 0;\n\n      let cap;\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));\n        if (cap) {\n          return {\n            type: 'em',\n            raw: src.slice(0, cap[0].length),\n            text: src.slice(1, cap[0].length - 1)\n          };\n        }\n      }\n    }\n  }\n\n  codespan(src) {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(/\\n/g, ' ');\n      const hasNonSpaceChars = /[^ ]/.test(text);\n      const hasSpaceCharsOnBothEnds = text.startsWith(' ') && text.endsWith(' ');\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      text = escape(text, true);\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  br(src) {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0]\n      };\n    }\n  }\n\n  del(src) {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[1]\n      };\n    }\n  }\n\n  autolink(src, mangle) {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n        href = 'mailto:' + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  url(src, mangle) {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n        } while (prevCapZero !== cap[0]);\n        text = escape(cap[0]);\n        if (cap[1] === 'www.') {\n          href = 'http://' + text;\n        } else {\n          href = text;\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  inlineText(src, inRawBlock, smartypants) {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      let text;\n      if (inRawBlock) {\n        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];\n      } else {\n        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n      }\n      return {\n        type: 'text',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n};\n","const {\n  noopTest,\n  edit,\n  merge\n} = require('./helpers.js');\n\n/**\n * Block-Level Grammar\n */\nconst block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n  heading: /^ {0,3}(#{1,6}) +([^\\n]*?)(?: +#+)? *(?:\\n+|$)/,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n  nptable: noopTest,\n  table: noopTest,\n  lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  // regex template, placeholders will be replaced according to different paragraph\n  // interruption rules of commonmark and the original markdown spec:\n  _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.item = /^( *)(bull) ?[^\\n]*(?:\\n(?!\\1bull ?)[^\\n]*)*/;\nblock.item = edit(block.item, 'gm')\n  .replace(/bull/g, block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  nptable: '^ *([^|\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}([-:]+ *\\\\|[-| :]*)' // Align\n    + '(?:\\\\n((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)', // Cells\n  table: '^ *\\\\|(.+)\\\\n' // Header\n    + ' {0,3}\\\\|?( *[-:]+[-| :]*)' // Align\n    + '(?:\\\\n *((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n});\n\nblock.gfm.nptable = edit(block.gfm.nptable)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.gfm.table = edit(block.gfm.table)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nblock.pedantic = merge({}, block.normal, {\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  paragraph: edit(block.normal._paragraph)\n    .replace('hr', block.hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', block.lheading)\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .getRegex()\n});\n\n/**\n * Inline-Level Grammar\n */\nconst inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noopTest,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n  nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n  reflinkSearch: 'reflink|nolink(?!\\\\()',\n  strong: {\n    start: /^(?:(\\*\\*(?=[*punctuation]))|\\*\\*)(?![\\s])|__/, // (1) returns if starts w/ punctuation\n    middle: /^\\*\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*\\*$|^__(?![\\s])((?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?)__$/,\n    endAst: /[^punctuation\\s]\\*\\*(?!\\*)|[punctuation]\\*\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/, // last char can't be punct, or final * must also be followed by punct (or endline)\n    endUnd: /[^\\s]__(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n  },\n  em: {\n    start: /^(?:(\\*(?=[punctuation]))|\\*)(?![*\\s])|_/, // (1) returns if starts w/ punctuation\n    middle: /^\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*$|^_(?![_\\s])(?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?_$/,\n    endAst: /[^punctuation\\s]\\*(?!\\*)|[punctuation]\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/, // last char can't be punct, or final * must also be followed by punct (or endline)\n    endUnd: /[^\\s]_(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n  },\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noopTest,\n  text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n  punctuation: /^([\\s*punctuation])/\n};\n\n// list of punctuation marks from common mark spec\n// without * and _ to workaround cases with double emphasis\ninline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\ninline._blockSkip = '\\\\[[^\\\\]]*?\\\\]\\\\([^\\\\)]*?\\\\)|`[^`]*?`|<[^>]*?>';\ninline._overlapSkip = '__[^_]*?__|\\\\*\\\\*\\\\[^\\\\*\\\\]*?\\\\*\\\\*';\n\ninline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();\n\ninline.em.start = edit(inline.em.start)\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.em.middle = edit(inline.em.middle)\n  .replace(/punctuation/g, inline._punctuation)\n  .replace(/overlapSkip/g, inline._overlapSkip)\n  .getRegex();\n\ninline.em.endAst = edit(inline.em.endAst, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.em.endUnd = edit(inline.em.endUnd, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.strong.start = edit(inline.strong.start)\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.strong.middle = edit(inline.strong.middle)\n  .replace(/punctuation/g, inline._punctuation)\n  .replace(/overlapSkip/g, inline._overlapSkip)\n  .getRegex();\n\ninline.strong.endAst = edit(inline.strong.endAst, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.strong.endUnd = edit(inline.strong.endUnd, 'g')\n  .replace(/punctuation/g, inline._punctuation)\n  .getRegex();\n\ninline.blockSkip = edit(inline._blockSkip, 'g')\n  .getRegex();\n\ninline.overlapSkip = edit(inline._overlapSkip, 'g')\n  .getRegex();\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', inline._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\[<>]?|[^\\s<>\\\\])*>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .getRegex();\n\ninline.reflinkSearch = edit(inline.reflinkSearch, 'g')\n  .replace('reflink', inline.reflink)\n  .replace('nolink', inline.nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: {\n    start: /^__|\\*\\*/,\n    middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n    endAst: /\\*\\*(?!\\*)/g,\n    endUnd: /__(?!_)/g\n  },\n  em: {\n    start: /^_|\\*/,\n    middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n    endAst: /\\*(?!\\*)/g,\n    endUnd: /_(?!_)/g\n  },\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n  del: /^~+(?=\\S)([\\s\\S]*?\\S)~+/,\n  text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n});\n\ninline.gfm.url = edit(inline.gfm.url, 'i')\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex()\n});\n\nmodule.exports = {\n  block,\n  inline\n};\n","const Tokenizer = require('./Tokenizer.js');\nconst { defaults } = require('./defaults.js');\nconst { block, inline } = require('./rules.js');\n\n/**\n * smartypants text replacement\n */\nfunction smartypants(text) {\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n}\n\n/**\n * mangle email addresses\n */\nfunction mangle(text) {\n  let out = '',\n    i,\n    ch;\n\n  const l = text.length;\n  for (i = 0; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n}\n\n/**\n * Block Lexer\n */\nmodule.exports = class Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n\n    const rules = {\n      block: block.normal,\n      inline: inline.normal\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n')\n      .replace(/\\t/g, '    ');\n\n    this.blockTokens(src, this.tokens, true);\n\n    this.inline(this.tokens);\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src, tokens = [], top = true) {\n    src = src.replace(/^ +$/gm, '');\n    let token, i, l, lastToken;\n\n    while (src) {\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        if (token.type) {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src, tokens)) {\n        src = src.substring(token.raw.length);\n        if (token.type) {\n          tokens.push(token);\n        } else {\n          lastToken = tokens[tokens.length - 1];\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // table no leading pipe (gfm)\n      if (token = this.tokenizer.nptable(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.blockTokens(token.text, [], top);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        l = token.items.length;\n        for (i = 0; i < l; i++) {\n          token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);\n        }\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (top && (token = this.tokenizer.def(src))) {\n        src = src.substring(token.raw.length);\n        if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      if (top && (token = this.tokenizer.paragraph(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src, tokens)) {\n        src = src.substring(token.raw.length);\n        if (token.type) {\n          tokens.push(token);\n        } else {\n          lastToken = tokens[tokens.length - 1];\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n\n  inline(tokens) {\n    let i,\n      j,\n      k,\n      l2,\n      row,\n      token;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n      switch (token.type) {\n        case 'paragraph':\n        case 'text':\n        case 'heading': {\n          token.tokens = [];\n          this.inlineTokens(token.text, token.tokens);\n          break;\n        }\n        case 'table': {\n          token.tokens = {\n            header: [],\n            cells: []\n          };\n\n          // header\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            token.tokens.header[j] = [];\n            this.inlineTokens(token.header[j], token.tokens.header[j]);\n          }\n\n          // cells\n          l2 = token.cells.length;\n          for (j = 0; j < l2; j++) {\n            row = token.cells[j];\n            token.tokens.cells[j] = [];\n            for (k = 0; k < row.length; k++) {\n              token.tokens.cells[j][k] = [];\n              this.inlineTokens(row[k], token.tokens.cells[j][k]);\n            }\n          }\n\n          break;\n        }\n        case 'blockquote': {\n          this.inline(token.tokens);\n          break;\n        }\n        case 'list': {\n          l2 = token.items.length;\n          for (j = 0; j < l2; j++) {\n            this.inline(token.items[j].tokens);\n          }\n          break;\n        }\n        default: {\n          // do nothing\n        }\n      }\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src, tokens = [], inLink = false, inRawBlock = false, prevChar = '') {\n    let token;\n\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    while (src) {\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {\n        src = src.substring(token.raw.length);\n        inLink = token.inLink;\n        inRawBlock = token.inRawBlock;\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        if (token.type === 'link') {\n          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n        }\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        if (token.type === 'link') {\n          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n        }\n        tokens.push(token);\n        continue;\n      }\n\n      // strong\n      if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n        tokens.push(token);\n        continue;\n      }\n\n      // em\n      if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src, mangle)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!inLink && (token = this.tokenizer.url(src, mangle))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {\n        src = src.substring(token.raw.length);\n        prevChar = token.raw.slice(-1);\n        tokens.push(token);\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n};\n","const { defaults } = require('./defaults.js');\nconst {\n  cleanUrl,\n  escape\n} = require('./helpers.js');\n\n/**\n * Renderer\n */\nmodule.exports = class Renderer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  code(code, infostring, escaped) {\n    const lang = (infostring || '').match(/\\S*/)[0];\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    if (!lang) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    }\n\n    return '<pre><code class=\"'\n      + this.options.langPrefix\n      + escape(lang, true)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  }\n\n  blockquote(quote) {\n    return '<blockquote>\\n' + quote + '</blockquote>\\n';\n  }\n\n  html(html) {\n    return html;\n  }\n\n  heading(text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      return '<h'\n        + level\n        + ' id=\"'\n        + this.options.headerPrefix\n        + slugger.slug(raw)\n        + '\">'\n        + text\n        + '</h'\n        + level\n        + '>\\n';\n    }\n    // ignore IDs\n    return '<h' + level + '>' + text + '</h' + level + '>\\n';\n  }\n\n  hr() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body, ordered, start) {\n    const type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  }\n\n  listitem(text) {\n    return '<li>' + text + '</li>\\n';\n  }\n\n  checkbox(checked) {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"'\n      + (this.options.xhtml ? ' /' : '')\n      + '> ';\n  }\n\n  paragraph(text) {\n    return '<p>' + text + '</p>\\n';\n  }\n\n  table(header, body) {\n    if (body) body = '<tbody>' + body + '</tbody>';\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  }\n\n  tablerow(content) {\n    return '<tr>\\n' + content + '</tr>\\n';\n  }\n\n  tablecell(content, flags) {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align\n      ? '<' + type + ' align=\"' + flags.align + '\">'\n      : '<' + type + '>';\n    return tag + content + '</' + type + '>\\n';\n  }\n\n  // span level renderer\n  strong(text) {\n    return '<strong>' + text + '</strong>';\n  }\n\n  em(text) {\n    return '<em>' + text + '</em>';\n  }\n\n  codespan(text) {\n    return '<code>' + text + '</code>';\n  }\n\n  br() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  del(text) {\n    return '<del>' + text + '</del>';\n  }\n\n  link(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n    let out = '<a href=\"' + escape(href) + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  }\n\n  image(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n\n    let out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  }\n\n  text(text) {\n    return text;\n  }\n};\n","/**\n * TextRenderer\n * returns only the textual part of the token\n */\nmodule.exports = class TextRenderer {\n  // no need for block level renderers\n  strong(text) {\n    return text;\n  }\n\n  em(text) {\n    return text;\n  }\n\n  codespan(text) {\n    return text;\n  }\n\n  del(text) {\n    return text;\n  }\n\n  html(text) {\n    return text;\n  }\n\n  text(text) {\n    return text;\n  }\n\n  link(href, title, text) {\n    return '' + text;\n  }\n\n  image(href, title, text) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n};\n","/**\n * Slugger generates header id\n */\nmodule.exports = class Slugger {\n  constructor() {\n    this.seen = {};\n  }\n\n  serialize(value) {\n    return value\n      .toLowerCase()\n      .trim()\n      // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '')\n      // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '')\n      .replace(/\\s/g, '-');\n  }\n\n  /**\n   * Finds the next safe (unique) slug to use\n   */\n  getNextSafeSlug(originalSlug, isDryRun) {\n    let slug = originalSlug;\n    let occurenceAccumulator = 0;\n    if (this.seen.hasOwnProperty(slug)) {\n      occurenceAccumulator = this.seen[originalSlug];\n      do {\n        occurenceAccumulator++;\n        slug = originalSlug + '-' + occurenceAccumulator;\n      } while (this.seen.hasOwnProperty(slug));\n    }\n    if (!isDryRun) {\n      this.seen[originalSlug] = occurenceAccumulator;\n      this.seen[slug] = 0;\n    }\n    return slug;\n  }\n\n  /**\n   * Convert string to unique id\n   * @param {object} options\n   * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n   */\n  slug(value, options = {}) {\n    const slug = this.serialize(value);\n    return this.getNextSafeSlug(slug, options.dryrun);\n  }\n};\n","const Renderer = require('./Renderer.js');\nconst TextRenderer = require('./TextRenderer.js');\nconst Slugger = require('./Slugger.js');\nconst { defaults } = require('./defaults.js');\nconst {\n  unescape\n} = require('./helpers.js');\n\n/**\n * Parsing & Compiling\n */\nmodule.exports = class Parser {\n  constructor(options) {\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.textRenderer = new TextRenderer();\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens, top = true) {\n    let out = '',\n      i,\n      j,\n      k,\n      l2,\n      l3,\n      row,\n      cell,\n      header,\n      body,\n      token,\n      ordered,\n      start,\n      loose,\n      itemBody,\n      item,\n      checked,\n      task,\n      checkbox;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n      switch (token.type) {\n        case 'space': {\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr();\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(\n            this.parseInline(token.tokens),\n            token.depth,\n            unescape(this.parseInline(token.tokens, this.textRenderer)),\n            this.slugger);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token.text,\n            token.lang,\n            token.escaped);\n          continue;\n        }\n        case 'table': {\n          header = '';\n\n          // header\n          cell = '';\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            cell += this.renderer.tablecell(\n              this.parseInline(token.tokens.header[j]),\n              { header: true, align: token.align[j] }\n            );\n          }\n          header += this.renderer.tablerow(cell);\n\n          body = '';\n          l2 = token.cells.length;\n          for (j = 0; j < l2; j++) {\n            row = token.tokens.cells[j];\n\n            cell = '';\n            l3 = row.length;\n            for (k = 0; k < l3; k++) {\n              cell += this.renderer.tablecell(\n                this.parseInline(row[k]),\n                { header: false, align: token.align[k] }\n              );\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n          out += this.renderer.table(header, body);\n          continue;\n        }\n        case 'blockquote': {\n          body = this.parse(token.tokens);\n          out += this.renderer.blockquote(body);\n          continue;\n        }\n        case 'list': {\n          ordered = token.ordered;\n          start = token.start;\n          loose = token.loose;\n          l2 = token.items.length;\n\n          body = '';\n          for (j = 0; j < l2; j++) {\n            item = token.items[j];\n            checked = item.checked;\n            task = item.task;\n\n            itemBody = '';\n            if (item.task) {\n              checkbox = this.renderer.checkbox(checked);\n              if (loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'text') {\n                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                  }\n                } else {\n                  item.tokens.unshift({\n                    type: 'text',\n                    text: checkbox\n                  });\n                }\n              } else {\n                itemBody += checkbox;\n              }\n            }\n\n            itemBody += this.parse(item.tokens, loose);\n            body += this.renderer.listitem(itemBody, task, checked);\n          }\n\n          out += this.renderer.list(body, ordered, start);\n          continue;\n        }\n        case 'html': {\n          // TODO parse inline content if parameter markdown=1\n          out += this.renderer.html(token.text);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(this.parseInline(token.tokens));\n          continue;\n        }\n        case 'text': {\n          body = token.tokens ? this.parseInline(token.tokens) : token.text;\n          while (i + 1 < l && tokens[i + 1].type === 'text') {\n            token = tokens[++i];\n            body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n          }\n          out += top ? this.renderer.paragraph(body) : body;\n          continue;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens, renderer) {\n    renderer = renderer || this.renderer;\n    let out = '',\n      i,\n      token;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token.text);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token.text);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token.href, token.title, token.text);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'em': {\n          out += renderer.em(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token.text);\n          break;\n        }\n        case 'br': {\n          out += renderer.br();\n          break;\n        }\n        case 'del': {\n          out += renderer.del(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token.text);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out;\n  }\n};\n","const Lexer = require('./Lexer.js');\nconst Parser = require('./Parser.js');\nconst Tokenizer = require('./Tokenizer.js');\nconst Renderer = require('./Renderer.js');\nconst TextRenderer = require('./TextRenderer.js');\nconst Slugger = require('./Slugger.js');\nconst {\n  merge,\n  checkSanitizeDeprecation,\n  escape\n} = require('./helpers.js');\nconst {\n  getDefaults,\n  changeDefaults,\n  defaults\n} = require('./defaults.js');\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (typeof opt === 'function') {\n    callback = opt;\n    opt = null;\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  if (callback) {\n    const highlight = opt.highlight;\n    let tokens;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    const done = function(err) {\n      let out;\n\n      if (!err) {\n        try {\n          out = Parser.parse(tokens, opt);\n        } catch (e) {\n          err = e;\n        }\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!tokens.length) return done();\n\n    let pending = 0;\n    marked.walkTokens(tokens, function(token) {\n      if (token.type === 'code') {\n        pending++;\n        setTimeout(() => {\n          highlight(token.text, token.lang, function(err, code) {\n            if (err) {\n              return done(err);\n            }\n            if (code != null && code !== token.text) {\n              token.text = code;\n              token.escaped = true;\n            }\n\n            pending--;\n            if (pending === 0) {\n              done();\n            }\n          });\n        }, 0);\n      }\n    });\n\n    if (pending === 0) {\n      done();\n    }\n\n    return;\n  }\n\n  try {\n    const tokens = Lexer.lex(src, opt);\n    if (opt.walkTokens) {\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parse(tokens, opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(extension) {\n  const opts = merge({}, extension);\n  if (extension.renderer) {\n    const renderer = marked.defaults.renderer || new Renderer();\n    for (const prop in extension.renderer) {\n      const prevRenderer = renderer[prop];\n      renderer[prop] = (...args) => {\n        let ret = extension.renderer[prop].apply(renderer, args);\n        if (ret === false) {\n          ret = prevRenderer.apply(renderer, args);\n        }\n        return ret;\n      };\n    }\n    opts.renderer = renderer;\n  }\n  if (extension.tokenizer) {\n    const tokenizer = marked.defaults.tokenizer || new Tokenizer();\n    for (const prop in extension.tokenizer) {\n      const prevTokenizer = tokenizer[prop];\n      tokenizer[prop] = (...args) => {\n        let ret = extension.tokenizer[prop].apply(tokenizer, args);\n        if (ret === false) {\n          ret = prevTokenizer.apply(tokenizer, args);\n        }\n        return ret;\n      };\n    }\n    opts.tokenizer = tokenizer;\n  }\n  if (extension.walkTokens) {\n    const walkTokens = marked.defaults.walkTokens;\n    opts.walkTokens = (token) => {\n      extension.walkTokens(token);\n      if (walkTokens) {\n        walkTokens(token);\n      }\n    };\n  }\n  marked.setOptions(opts);\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens, callback) {\n  for (const token of tokens) {\n    callback(token);\n    switch (token.type) {\n      case 'table': {\n        for (const cell of token.tokens.header) {\n          marked.walkTokens(cell, callback);\n        }\n        for (const row of token.tokens.cells) {\n          for (const cell of row) {\n            marked.walkTokens(cell, callback);\n          }\n        }\n        break;\n      }\n      case 'list': {\n        marked.walkTokens(token.items, callback);\n        break;\n      }\n      default: {\n        if (token.tokens) {\n          marked.walkTokens(token.tokens, callback);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Parse Inline\n */\nmarked.parseInline = function(src, opt) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked.parseInline(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked.parseInline(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  try {\n    const tokens = Lexer.lexInline(src, opt);\n    if (opt.walkTokens) {\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parseInline(tokens, opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.Tokenizer = Tokenizer;\n\nmarked.Slugger = Slugger;\n\nmarked.parse = marked;\n\nmodule.exports = marked;\n","/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.0.8/LICENSE */\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar hasOwnProperty = Object.hasOwnProperty,\n    setPrototypeOf = Object.setPrototypeOf,\n    isFrozen = Object.isFrozen;\nvar freeze = Object.freeze,\n    seal = Object.seal,\n    create = Object.create; // eslint-disable-line import/no-mutable-exports\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect,\n    apply = _ref.apply,\n    construct = _ref.construct;\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\n\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n  };\n}\n\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\n\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf = unapply(String.prototype.indexOf);\nvar stringTrim = unapply(String.prototype.trim);\n\nvar regExpTest = unapply(RegExp.prototype.test);\n\nvar typeErrorCreate = unconstruct(TypeError);\n\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return construct(func, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === 'string') {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = create(null);\n\n  var property = void 0;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\nvar html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nvar svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);\n\nvar svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\nvar mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\nvar text = freeze(['#text']);\n\nvar html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);\n\nvar svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\nvar mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\nvar xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n// eslint-disable-next-line unicorn/better-regex\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '2.1.1';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      getElementsByTagName = _document.getElementsByTagName,\n      createDocumentFragment = _document.createDocumentFragment;\n  var importNode = originalDocument.importNode;\n\n\n  var documentMode = {};\n  try {\n    documentMode = clone(document).documentMode ? document.documentMode : {};\n  } catch (_) {}\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify. */\n  var RETURN_DOM_IMPORT = false;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = null;\n  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html);\n        addToSet(ALLOWED_ATTR, html$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      node.parentNode.removeChild(node);\n    } catch (_) {\n      node.outerHTML = emptyHTML;\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /* Use the DOMParser API by default, fallback later if needs be */\n    try {\n      doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n    } catch (_) {}\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createHTMLDocument('');\n      var _doc = doc,\n          body = _doc.body;\n\n      body.parentNode.removeChild(body.parentNode.firstElementChild);\n      body.outerHTML = dirtyPayload;\n    }\n\n    if (dirty && leadingWhitespace) {\n      doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n  };\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {\n      return NodeFilter.FILTER_ACCEPT;\n    }, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(object) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check if tagname contains Unicode */\n    if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    var tagName = stringToLowerCase(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Take care of an mXSS pattern using p, br inside svg, math */\n    if ((tagName === 'svg' || tagName === 'math') && currentNode.querySelectorAll('p, br').length !== 0) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[!/\\w]/g, currentNode.innerHTML) && regExpTest(/<[!/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {\n        try {\n          var htmlToInsert = currentNode.innerHTML;\n          currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);\n        } catch (_) {}\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove in case a noscript/noembed XSS is suspected */\n    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n      content = stringReplace(content, ERB_EXPR$$1, ' ');\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = stringTrim(attr.value);\n      lcName = stringToLowerCase(name);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n        value = stringReplace(value, ERB_EXPR$$1, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = currentNode.nodeName.toLowerCase();\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (_) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    if (!dirty) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw typeErrorCreate('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) ; else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n      // eslint-disable-next-line unicorn/prefer-includes\n      dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = stringToLowerCase(tag);\n    var lcName = stringToLowerCase(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\nexport default purify;\n//# sourceMappingURL=purify.es.js.map\n","// @ts-check\n\nimport { TextEditor } from 'atom';\nimport { scopeForFenceName, fenceNameForScope } from './utils';\nimport marked from 'marked';\n\n /**\n  * safe DOM markup operations\n  * a reference to the DOMpurify function to make safe HTML strings\n  * @type {DOMPurify}\n  */\n import DOMPurify from \"dompurify\";\n\n\n/**\n * iterates over the content of the HTML fragment and replaces any code section\n * found with an Atom TextEditor element that is used for syntax highlighting the code\n *\n * @param  {HTMLElement} domFragment the HTML fragment to be analyzed and\n * @param  {String} grammar     the default grammar to be used if the code section doesn't have a specific grammar set\n * @return {Promise}  a promise that is resolved when the fragment is ready\n */\nasync function highlightCodeFragments(domFragment: HTMLElement, grammar: string): Promise {\n  const defaultLanguage = fenceNameForScope(grammar || 'text.plain');\n  // set editor font family\n  const fontFamily = atom.config.get('editor.fontFamily');\n  const fontSize = atom.config.get('editor.fontSize');\n  if (fontFamily !== null) {\n    domFragment.querySelectorAll('code').forEach(codeElement => {\n      codeElement.style.fontFamily = fontFamily;\n      codeElement.style.fontSize = `${fontSize}`;\n    });\n  }\n\n  const elements: HTMLElement[] = [].slice.call(domFragment.querySelectorAll('pre'));\n  const promises = elements.map(async (preElement) => {\n    let codeBlock = preElement.firstElementChild ?? preElement;\n    let fenceName = codeBlock.getAttribute('class')?.replace(/^lang-/, '').replace(/^language-/, '') ?? defaultLanguage;\n    preElement.classList.add('editor-colors', `lang-${fenceName}`);\n\n    let editor = new TextEditor({\n      readonly: true,\n      keyboardInputEnabled: false,\n      softWrapped: true,\n      softWrapAtPreferredLineLength: true,\n      preferredLineLength: 80\n    });\n    let editorElement: Element = editor.getElement();\n    editorElement.setUpdatedSynchronously(true);\n\n    preElement.innerHTML = '';\n    preElement.parentNode.insertBefore(editorElement, preElement);\n\n    editor.setText(codeBlock.textContent.replace(/\\r?\\n$/, ''));\n\n    atom.grammars.assignLanguageMode(editor, scopeForFenceName(fenceName));\n    editor.setVisible(true);\n    return await tokenizeEditor(editorElement, preElement);\n  });\n\n  return await Promise.all(promises);\n}\n\n/**\n * takes an Atom TextEditor element, tokenize the content and move the resulting lines to the pre element given\n * @param  {HTMLElement} editorElement the HTML element containing the Atom TextEditor\n * @param  {HTMLPreElement} preElement    the HTML pre element that should host the resulting lines\n * @return {Promise}  a promise that is triggered as soon as tokenization and moving the content is done\n */\nfunction tokenizeEditor(editorElement: HTMLElement, preElement: HTMLPreElement): Promise {\n  let p = new Promise((resolve, reject) => {\n    let done = () => {\n      editorElement.querySelectorAll('.line:not(.dummy)').forEach((line) => {\n       let line2 = document.createElement('div');\n       line2.className = 'line';\n       line2.innerHTML = line.firstChild.innerHTML;\n       preElement.appendChild(line2);\n      });\n      editorElement.remove();\n      resolve();\n    }\n    const editor = editorElement.getModel();\n    const languageMode = editor.getBuffer().getLanguageMode();\n    if ((languageMode.fullyTokenized) || (languageMode.tree)) {\n      editor.component.getNextUpdatePromise().then(() => {\n        done();\n      })\n      .catch(reject);\n    }\n    else {\n      editor.onDidTokenize(() => {\n        done();\n      });\n    }\n  });\n  return p;\n}\n\n/**\n * renders markdown to safe HTML\n * @param  {String} markdownText the markdown text to render\n * @return {Node} the html template node containing the result\n */\nfunction internalRender(markdownText: string): Node {\n  let html = DOMPurify.sanitize(marked(markdownText, { breaks: true }));\n  let template = document.createElement('template');\n  template.innerHTML = html.trim();\n  return template.content.cloneNode(true);\n}\n\n/**\n * renders the markdown text to html\n * @param  {string} markdownText the markdown text to render\n * @param  {string} grammar the default grammar used in code sections that have no specific grammar set\n * @return {Promise<string>} the inner HTML text of the rendered section\n */\nexport async function render (markdownText: string, grammar: string): Promise<string> {\n    let node = internalRender(markdownText);\n    let div = document.createElement('div');\n    div.appendChild(node);\n    document.body.appendChild(div);\n\n    await highlightCodeFragments(div, grammar);\n    div.remove();\n    return div.innerHTML;\n}\n","// @ts-check\n\nimport { CompositeDisposable } from 'atom';\nimport { render } from './renderer';\nimport type { MarkdownService } from \"atom-ide-base\"\n\n/**\n * the Atom IDE markdown service plugin\n * @type {Object}\n */\n\n/**\n * [subscriptions description]\n * @type {CompositeDisposable}\n */\nlet subscriptions: CompositeDisposable\n\n/**\n* called by Atom when activating an extension\n* @param  {any} state the current state of atom\n*/\nexport function activate(state: any) {\n    // Events subscribed to in atom's system can be easily cleaned up with a CompositeDisposable\n    subscriptions = new CompositeDisposable();\n}\n\n/**\n * called by Atom when deactivating an extension\n */\nexport function deactivate() {\n    if (subscriptions) {\n      subscriptions.dispose();\n    }\n    subscriptions = null;\n}\n\n/**\n * provide an interface to the Markdown renderer service\n * @return {MarkdownService} the markdown renderer service\n */\nexport function provideMarkdownRenderer(): MarkdownService {\n    return {render};\n}\n"],"names":["scopesByFenceName","getDefaults","baseUrl","breaks","gfm","headerIds","headerPrefix","highlight","langPrefix","mangle","pedantic","renderer","sanitize","sanitizer","silent","smartLists","smartypants","tokenizer","walkTokens","xhtml","module","defaults","changeDefaults","newDefaults","escapeTest","escapeReplace","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","ch","unescapeTest","unescape","html","replace","_","n","toLowerCase","charAt","String","fromCharCode","parseInt","substring","caret","nonWordAndColonTest","originIndependentUrl","baseUrls","justDomain","protocol","domain","resolveUrl","base","href","test","rtrim","relativeBase","indexOf","str","c","invert","l","length","suffLen","currChar","substr","escape","encode","edit","regex","opt","source","obj","name","val","getRegex","RegExp","cleanUrl","prot","decodeURIComponent","e","encodeURI","noopTest","exec","merge","target","key","i","arguments","Object","prototype","hasOwnProperty","call","splitCells","tableRow","count","cells","match","offset","escaped","curr","split","splice","push","trim","findClosingBracket","b","level","checkSanitizeDeprecation","console","warn","require","outputLink","cap","link","raw","title","text","type","constructor","options","space","src","this","rules","block","newline","code","tokens","lastToken","trimRight","codeBlockStyle","fences","matchIndentToCode","indentToCode","map","node","matchIndentInNode","indentInNode","slice","join","indentCodeCompensation","lang","heading","depth","nptable","item","header","align","hr","blockquote","list","bull","isordered","isparen","ordered","start","loose","items","itemMatch","addBack","istask","ischecked","next","bullet","undefined","task","checked","pre","def","tag","table","lheading","paragraph","inline","inLink","inRawBlock","lastParenIndex","linkLen","_escapes","reflink","links","nolink","strong","maskedSrc","prevChar","punctuation","endReg","endAst","endUnd","lastIndex","middle","index","em","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","startsWith","endsWith","br","del","autolink","url","prevCapZero","_backpedal","inlineText","_paragraph","_label","_title","_tag","_comment","normal","reflinkSearch","_punctuation","_blockSkip","_overlapSkip","blockSkip","overlapSkip","_scheme","_email","_attribute","_href","_extended_email","out","charCodeAt","Math","random","toString","Lexer","create","Tokenizer","lex","inlineTokens","blockTokens","top","token","errMsg","error","Error","j","k","l2","row","keys","includes","lastIndexOf","repeat","infostring","quote","slugger","slug","body","listitem","checkbox","tablerow","content","tablecell","flags","image","seen","serialize","value","getNextSafeSlug","originalSlug","isDryRun","occurenceAccumulator","dryrun","Parser","Renderer","textRenderer","TextRenderer","Slugger","parse","parseInline","l3","cell","itemBody","unshift","marked","callback","done","err","pending","setTimeout","message","setOptions","use","extension","opts","prop","prevRenderer","args","ret","apply","prevTokenizer","lexInline","parser","lexer","setPrototypeOf","isFrozen","freeze","seal","Reflect","construct","fun","thisValue","x","Func","concat","_toConsumableArray","func","arrayForEach","unapply","Array","forEach","arrayPop","pop","arrayPush","stringToLowerCase","stringMatch","stringReplace","stringIndexOf","stringTrim","regExpTest","typeErrorCreate","TypeError","_len2","_key2","thisArg","_len","_key","addToSet","set","array","element","lcElement","clone","object","newObject","property","async","highlightCodeFragments","domFragment","grammar","defaultLanguage","scope","resultOut","result","filter","s","fenceNameForScope","fontFamily","atom","config","get","fontSize","querySelectorAll","codeElement","style","promises","codeBlock","preElement","firstElementChild","fenceName","getAttribute","_codeBlock$getAttribu2","classList","add","editor","TextEditor","readonly","keyboardInputEnabled","softWrapped","softWrapAtPreferredLineLength","preferredLineLength","editorElement","getElement","setUpdatedSynchronously","innerHTML","parentNode","insertBefore","setText","textContent","grammars","assignLanguageMode","scopeForFenceName","setVisible","Promise","resolve","reject","line","line2","document","createElement","className","firstChild","appendChild","remove","getModel","languageMode","getBuffer","getLanguageMode","fullyTokenized","tree","component","getNextUpdatePromise","then","catch","onDidTokenize","tokenizeEditor","all","render","markdownText","DOMPurify","template","cloneNode","internalRender","div","subscriptions","state","CompositeDisposable","dispose"],"mappings":"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"}